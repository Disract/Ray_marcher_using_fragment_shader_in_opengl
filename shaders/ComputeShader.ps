#version 430 core
#define MAX_STEPS 56
#define MIN_HIT_DISTANCE 0.001
#define MAX_TRACE_DISTANCE 1000.0

layout (local_size_x = 10,local_size_y = 10, local_size_z = 1) in;
layout(rgba32f,binding = 0) uniform image2D imgOutput;
layout (location = 0) uniform float t;
uniform mat4 roatation;
uniform float angle;


float distance_from_sphere(vec3 point,vec3 center,float radius)
{
    return (length(point-center) - radius);
}
float distance_from_cylinder(vec3 point, float radius)
{
    return length(point.xz) - radius;
}
float map_the_world(vec3 point)
{
    float displacement = sin(t * point.x) * sin(t * point.y)  * sin(t*point.z) * 0.5;

    float debug_displacement = sin(3 * point.x) * sin(3 * point.y) *sin(3 * point.z) * 0.5;
    mat2 rotY = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));
    point.xz *= 1;

    vec3 point_temp1 = vec3(mod(point.x + 3, 4) - 2,point.y, mod(point.z+3,4)-2 );
    vec3 point_temp2 = vec3(mod(point.x + 3, 3) - 2,point.y, mod(point.z+3,3)-2 );
    vec3 point_temp3 = vec3(mod(point.x + 3, 3) - 2 ,mod(point.y + 3, 3) - 2 ,mod(point.z + 3, 3) - 2);
    float sphere_1 = distance_from_sphere(point_temp3+vec3(0,0,0),vec3(0.0,0.0,0.0),0.5);
    
    float sphere_2 = distance_from_sphere( ( roatation * vec4(point,1)  ).xyz,vec3(0.0,0.0,0.0),1.0);
    float cylinder_1 = distance_from_cylinder( vec3(1.0,0.0,1.0),1.0);


    return (sphere_1 +   displacement  );
}
vec3 calculate_normal(vec3 point)
{
    const vec3 small_step = vec3(0.001,0.0,0.0);

    float gradient_x = map_the_world(point + small_step.xyy) - map_the_world(point - small_step.xyy);
    float gradient_y = map_the_world(point + small_step.yxy) - map_the_world(point - small_step.yxy);
    float gradient_z = map_the_world(point + small_step.yyx) - map_the_world(point - small_step.yyx);

    vec3 normal = vec3(gradient_x,gradient_y,gradient_z);

    return normalize(normal);
}
vec3 ray_march(vec3 ray_origin,vec3 ray_direction)
{
    float total_distance_covered = 0.0;
    for(int i=0;i<MAX_STEPS;++i)
    {
        vec3 current_postion = ray_origin + total_distance_covered * ray_direction;
        float distance_to_closest_surface = map_the_world(current_postion);
        distance_to_closest_surface *= 0.8;
        if(distance_to_closest_surface  < MIN_HIT_DISTANCE)
        {
            vec3 normal = calculate_normal(current_postion);
            return normal * 100.0 + 0.0;
        }
        if(total_distance_covered > MAX_TRACE_DISTANCE)
        {
            break;
        }
        total_distance_covered += distance_to_closest_surface ;
       
    }
     return vec3(1.0,1.0,1.0);
}


void main()
{
    vec4 value = vec4(0.0, 0.0, 0.0, 1.0);
    vec4 temp =  vec4(0.0, 0.0, 0.0, 1.0);

    ivec2 dims = imageSize(imgOutput);
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

    float x = -(float(texelCoord.x)*2.0-dims.x)  / float(dims.x);
    float y = -(float(texelCoord.y)*2.0-dims.y) / float(dims.y);

    vec3 camera_postion = vec3(0.0,-5.0,-30.0);
    vec3 ray_origin = camera_postion;
    vec3 ray_direction = normalize(vec3(float(x),float(y),1.0));
    vec3 color = ray_march(ray_origin,ray_direction);


    temp.x = float(texelCoord.x) / (gl_NumWorkGroups.x);
    temp.y = float(texelCoord.y) / (gl_NumWorkGroups.y);

    value = vec4(color,1.0);

    imageStore(imgOutput, texelCoord, value);

}